<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus Route Tracker</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Hidden checkboxes for CSS control -->
    <input type="checkbox" id="animationToggle" class="d-none">
    <input type="checkbox" id="pauseToggle" class="d-none">
    <input type="checkbox" id="resetToggle" class="d-none">
    <input type="radio" name="speed" id="speed05" class="d-none" checked>
    <input type="radio" name="speed" id="speed1" class="d-none">
    <input type="radio" name="speed" id="speed2" class="d-none">
    <input type="radio" name="speed" id="speed5" class="d-none">
    <input type="radio" name="direction" id="dir1" class="d-none" checked>
    <input type="radio" name="direction" id="dir2" class="d-none">
    
    <div class="app-container">
        <!-- Route Header -->
        <div class="route-header">
            <h2 class="route-title mb-0">{{ values.travel.name }}</h2>
            
            <!-- Direction Tabs -->
            <div class="direction-tabs mt-3">
                <div class="tabs-wrapper">
                    <label for="dir1" class="direction-tab">{{ values.travel.name }}</label>
                </div>
            </div>
        </div>
        
        <!-- Route Content -->
        <div class="route-content">
            <!-- Route Line and Stops -->
            <div class="route-visualization">
                <div class="route-line"></div>
                
                <!-- Bus Icon (animated) -->
                <div class="bus-icon-mobile">
                    <i class="bi bi-bus-front-fill"></i>
                </div>
                
                <!-- Stops List -->
                <div class="stops-list">
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.0.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.0.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.1.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.1.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.2.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.2.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.3.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.3.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.4.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.4.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.5.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.5.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="stop-item">
                        <div class="stop-circle"></div>
                        <div class="bus-card">
                            <div class="d-flex align-items-start">
                                <div class="bus-icon-small">
                                    <i class="bi bi-bus-front"></i>
                                </div>
                                <div class="flex-grow-1 ms-3">
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="align-items-center mb-2">
                                            <div class="bus-location">{{values.travel.stops.6.stop}}</div>
                                            <div class="arrival-clock">{{values.travel.stops.6.arrival_time}}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Controls (for animation) -->
        <div class="controls-panel">
            <label for="animationToggle" class="btn btn-success btn-sm">
                <i class="bi bi-play-fill play-icon"></i>
                <i class="bi bi-stop-fill stop-icon d-none"></i>
                Start
            </label>
            <label for="pauseToggle" class="btn btn-warning btn-sm" id="pauseResumeBtn">
                <i class="bi bi-pause-fill pause-icon"></i>
                <i class="bi bi-play-fill resume-icon d-none"></i>
                <span class="pause-resume-text">Pause</span>
            </label>
            <button type="button" class="btn btn-danger btn-sm" onclick="stopEverything(); return false;">
                <i class="bi bi-stop-fill"></i>
                Stop
            </button>
            <input type="file" id="valuesFile" accept=".json,application/json" style="display: none;" onchange="handleFileSelect(event)">
        </div>
    </div>
    
    <!-- Script to load and populate values -->
    <script>
        // Fallback data (will be used if file can't be loaded)
        const fallbackData = {
            "travel": {
                "name": "",
                "stops": [
                    
                ]
            }
        };
        
        let currentData = fallbackData;
        let currentTime = null; // Current time that updates every second
        let timeUpdateInterval = null; // Interval for updating time
        let startTime = null; // Time when start button is clicked (frozen)
        let pauseTimeUpdateInterval = null; // Interval for updating time when paused
        let currentStopIndex = 0; // Index of the stop the bus is currently approaching
        let reachedStops = []; // Array to track which stops have been reached (their times are frozen)
        let pausedTimeOffset = 0; // Time offset when paused (seconds)
        let originalArrivalTimes = []; // Store original arrival times for each stop
        
        // Function to get current time in "HH:MM:SS AM/PM" format (Indonesia Time - WIB, UTC+7)
        function getCurrentTimeString() {
            const now = new Date();
            // Convert to Indonesia time (WIB - UTC+7)
            const indonesiaTime = new Date(now.toLocaleString("en-US", {timeZone: "Asia/Jakarta"}));
            
            let hours = indonesiaTime.getHours();
            const minutes = indonesiaTime.getMinutes();
            const seconds = indonesiaTime.getSeconds();
            const period = hours >= 12 ? 'PM' : 'AM';
            
            hours = hours % 12;
            if (hours === 0) hours = 12;
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} ${period}`;
        }
        
        // Function to add seconds to a time string
        function addSecondsToTimeString(timeStr, secondsToAdd) {
            function parseTime(timeStr) {
                const [timePart, period] = timeStr.trim().split(/\s+/);
                const parts = timePart.split(':');
                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                const seconds = parseInt(parts[2]) || 0;
                let totalSeconds = hours * 3600 + minutes * 60 + seconds;
                if (period) {
                    const periodUpper = period.toUpperCase();
                    if (periodUpper === 'PM' && hours !== 12) {
                        totalSeconds += 12 * 3600;
                    } else if (periodUpper === 'AM' && hours === 12) {
                        totalSeconds -= 12 * 3600;
                    }
                }
                return totalSeconds;
            }
            
            function formatTime(totalSeconds) {
                const hours24 = Math.floor(totalSeconds / 3600) % 24;
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                let hours12 = hours24 % 12;
                if (hours12 === 0) hours12 = 12;
                const period = hours24 >= 12 ? 'PM' : 'AM';
                
                return `${hours12.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')} ${period}`;
            }
            
            const totalSeconds = parseTime(timeStr) + secondsToAdd;
            return formatTime(totalSeconds);
        }
        
        // Function to calculate arrival times based on current time and add_time
        function calculateArrivalTimes() {
            if (!currentData.travel || !currentData.travel.stops) return;
            
            const baseTime = startTime || currentTime || getCurrentTimeString();
            let cumulativeTime = 0;
            
            currentData.travel.stops.forEach((stop, index) => {
                if (index === 0) {
                    // First stop uses the base time
                    if (reachedStops.includes(index)) {
                        // If reached, use frozen original time
                        if (originalArrivalTimes[index]) {
                            stop.arrival_time = originalArrivalTimes[index];
                        } else {
                            stop.arrival_time = baseTime;
                            originalArrivalTimes[index] = baseTime;
                        }
                    } else {
                        // If not reached, add paused time offset to all future stops
                        const originalTime = originalArrivalTimes[index] || baseTime;
                        if (pausedTimeOffset > 0) {
                            stop.arrival_time = addSecondsToTimeString(originalTime, pausedTimeOffset);
                        } else {
                            stop.arrival_time = originalTime;
                            if (!originalArrivalTimes[index]) {
                                originalArrivalTimes[index] = originalTime;
                            }
                        }
                    }
                } else {
                    // Subsequent stops: base time + cumulative add_time
                    cumulativeTime += stop.add_time || 0;
                    const calculatedTime = addSecondsToTimeString(baseTime, cumulativeTime);
                    
                    if (reachedStops.includes(index)) {
                        // If reached, use frozen original time
                        if (originalArrivalTimes[index]) {
                            stop.arrival_time = originalArrivalTimes[index];
                        } else {
                            stop.arrival_time = calculatedTime;
                            originalArrivalTimes[index] = calculatedTime;
                        }
                    } else {
                        // If not reached, add paused time offset to all future stops
                        const originalTime = originalArrivalTimes[index] || calculatedTime;
                        if (pausedTimeOffset > 0) {
                            stop.arrival_time = addSecondsToTimeString(originalTime, pausedTimeOffset);
                        } else {
                            stop.arrival_time = originalTime;
                            if (!originalArrivalTimes[index]) {
                                originalArrivalTimes[index] = originalTime;
                            }
                        }
                    }
                }
            });
        }
        
        // Function to update time display
        function updateTimeDisplay() {
            if (!currentData.travel || !currentData.travel.stops) return;
            
            calculateArrivalTimes();
            
            // Update all arrival-clock elements
            const arrivalClocks = document.querySelectorAll('.arrival-clock');
            arrivalClocks.forEach((clock, index) => {
                if (currentData.travel.stops[index]) {
                    clock.textContent = currentData.travel.stops[index].arrival_time;
                }
            });
        }
        
        // Start time update interval when page loads
        function startTimeUpdate() {
            // Get current time
            currentTime = getCurrentTimeString();
            
            // Calculate initial arrival times
            calculateArrivalTimes();
            updateTimeDisplay();
            
            // Update time every second
            timeUpdateInterval = setInterval(() => {
                if (!startTime) { // Only update if start button hasn't been clicked
                    currentTime = getCurrentTimeString();
                    calculateArrivalTimes();
                    updateTimeDisplay();
                }
            }, 1000);
        }
        
        // Function to get current bus position and determine which stop is being approached
        function getCurrentBusStopIndex() {
            const busIcon = document.querySelector('.bus-icon-mobile');
            if (!busIcon || !currentData.travel || !currentData.travel.stops) {
                console.log('getCurrentBusStopIndex: No bus icon or travel data');
                return 0;
            }
            
            const stops = currentData.travel.stops;
            const computedStyle = window.getComputedStyle(busIcon);
            const animName = computedStyle.animationName;
            const animPlayState = computedStyle.animationPlayState;
            const busTop = parseFloat(computedStyle.top) || 62;
            
            // Only log when animation state changes or when stop is reached
            // console.log('getCurrentBusStopIndex: busTop=', busTop, 'animName=', animName, 'animPlayState=', animPlayState);
            
            // If animation is not running or paused, return current stop index
            if (animPlayState === 'paused' || !animName || animName === 'none') {
                // Don't log every time when paused - too verbose
                // console.log('getCurrentBusStopIndex: Animation paused or not running, returning current stop index:', currentStopIndex);
                return currentStopIndex;
            }
            
            // Get bus position from top value
            const baseTopPx = 62;
            const stopSpacingPx = 112;
            
            // Calculate which stop based on position
            for (let i = 0; i < stops.length; i++) {
                const stopTopPx = baseTopPx + (i * stopSpacingPx);
                const nextStopTopPx = i < stops.length - 1 ? baseTopPx + ((i + 1) * stopSpacingPx) : stopTopPx;
                
                // Check if bus has reached this stop (within 5px tolerance)
                if (busTop >= stopTopPx - 5 && busTop < nextStopTopPx + 5) {
                    // Bus is at or past this stop
                    if (!reachedStops.includes(i) && busTop >= stopTopPx - 2) {
                        // Mark stop as reached and store its original time
                        reachedStops.push(i);
                        reachedStops.sort((a, b) => a - b);
                        console.log('Stop', i, 'reached! Reached stops:', reachedStops);
                        // Store the current arrival time as the original (frozen) time
                        if (currentData.travel.stops[i]) {
                            originalArrivalTimes[i] = currentData.travel.stops[i].arrival_time;
                            console.log('Stored original time for stop', i, ':', originalArrivalTimes[i]);
                        }
                    }
                    // Set current stop to next one if this one is reached
                    if (reachedStops.includes(i)) {
                        currentStopIndex = Math.min(i + 1, stops.length - 1);
                    } else {
                        currentStopIndex = i;
                    }
                    console.log('Current stop index set to:', currentStopIndex);
                    break;
                }
            }
            
            return currentStopIndex;
        }
        
        // Function to start tracking bus position
        let busTrackingInterval = null;
        function startBusPositionTracking() {
            if (busTrackingInterval) {
                clearInterval(busTrackingInterval);
            }
            
            busTrackingInterval = setInterval(() => {
                const animationToggle = document.getElementById('animationToggle');
                if (animationToggle && animationToggle.checked) {
                    getCurrentBusStopIndex();
                } else {
                    if (busTrackingInterval) {
                        clearInterval(busTrackingInterval);
                        busTrackingInterval = null;
                    }
                }
            }, 100); // Check every 100ms
        }
        
        // Function to update time when paused
        function startPauseTimeUpdate() {
            // console.log('startPauseTimeUpdate called');
            if (pauseTimeUpdateInterval) {
                clearInterval(pauseTimeUpdateInterval);
                // console.log('Cleared existing pause time update interval');
            }
            
            // Store original times for all unreached stops when pausing
            if (!currentData.travel || !currentData.travel.stops) {
                console.log('No travel data available');
                return;
            }
            // Store original times for all stops that haven't been reached yet
            currentData.travel.stops.forEach((stop, index) => {
                if (!reachedStops.includes(index) && !originalArrivalTimes[index]) {
                    originalArrivalTimes[index] = stop.arrival_time;
                    console.log('Stored original time for stop', index, ':', originalArrivalTimes[index]);
                }
            });
            
            // console.log('Starting pause time update interval');
            pauseTimeUpdateInterval = setInterval(() => {
                const pauseToggle = document.getElementById('pauseToggle');
                if (pauseToggle && pauseToggle.checked) {
                    // Increment paused time offset
                    pausedTimeOffset++;
                    // Only log every 5 seconds to reduce console spam
                    if (pausedTimeOffset % 5 === 0) {
                        console.log('Paused time offset:', pausedTimeOffset, 'seconds');
                    }
                    // Update current stop's time only
                    calculateArrivalTimes();
                    updateTimeDisplay();
                } else {
                    // console.log('Pause toggle unchecked, stopping interval');
                    clearInterval(pauseTimeUpdateInterval);
                    pauseTimeUpdateInterval = null;
                }
            }, 1000);
        }
        
        // Function to stop pause time update
        function stopPauseTimeUpdate() {
            // console.log('stopPauseTimeUpdate called');
            if (pauseTimeUpdateInterval) {
                clearInterval(pauseTimeUpdateInterval);
                pauseTimeUpdateInterval = null;
                // console.log('Pause time update interval cleared');
            }
            // When resuming, update original times for all unreached stops and reset offset
            if (!currentData.travel || !currentData.travel.stops) {
                // console.log('No travel data available');
                return;
            }
            if (pausedTimeOffset > 0) {
                // Update original times for all unreached stops with their new paused times
                currentData.travel.stops.forEach((stop, index) => {
                    if (!reachedStops.includes(index)) {
                        console.log('Resume: Updated stop', index, 'time from', originalArrivalTimes[index], 'to', stop.arrival_time, '(paused for', pausedTimeOffset, 'seconds)');
                        originalArrivalTimes[index] = stop.arrival_time;
                    }
                });
                pausedTimeOffset = 0;
                // console.log('Reset paused time offset to 0');
            }
        }
        
        // Stop everything function
        function stopEverything() {
            // Stop the animation
            const animationToggle = document.getElementById('animationToggle');
            if (animationToggle) {
                animationToggle.checked = false;
            }
            
            // Uncheck pause toggle
            const pauseToggle = document.getElementById('pauseToggle');
            if (pauseToggle) {
                pauseToggle.checked = false;
            }
            
            // Remove pause style override
            const pauseStyle = document.getElementById('pause-style-override');
            if (pauseStyle) {
                pauseStyle.remove();
            }
            
            // Stop time update intervals
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
            
            stopPauseTimeUpdate();
            
            // Reset tracking variables
            currentStopIndex = 0;
            reachedStops = [];
            pausedTimeOffset = 0;
            originalArrivalTimes = [];
            
            // Freeze the current time (don't update anymore)
            if (!startTime) {
                startTime = currentTime || getCurrentTimeString();
            }
        }
        
        // Handle file selection (hidden, can be triggered programmatically if needed)
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    currentData = data;
                    processData(data);
                    // Restart time update if not already started
                    if (timeUpdateInterval) {
                        clearInterval(timeUpdateInterval);
                    }
                    startTime = null; // Reset start time when new file is loaded
                    startTimeUpdate();
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        
        async function loadValues() {
            let data = fallbackData;
            let loadedFromFile = false;
            
            try {
                // Try both 'values' and 'values.json'
                let response;
                try {
                    response = await fetch('values.json');
                    if (!response.ok) {
                        throw new Error('values.json not found');
                    }
                } catch (e) {
                    response = await fetch('values');
                }
                
                if (response && response.ok) {
                    data = await response.json();
                    currentData = data;
                    loadedFromFile = true;
                } else {
                }
            } catch (error) {
            }
            
            processData(data);
            
            // Start time update after data is loaded
            startTimeUpdate();
        }
        
        function processData(data) {
            currentData = data;
            
            // Calculate arrival times BEFORE processing placeholders
            // Get current time first (Indonesia time)
            if (!currentTime) {
                currentTime = getCurrentTimeString();
            }
            // Make sure arrival times are calculated before replacing placeholders
            calculateArrivalTimes();
            
                
                // Helper function to extract first part of stop name
                function getStopName(fullStop) {
                    return fullStop.split(',')[0].trim();
                }
                
                // Helper function to format time (keep seconds)
                function formatTime(timeStr) {
                    // Keep the time as is, just ensure proper formatting
                    if (!timeStr) return '00:00:00 AM';
                    return timeStr.trim();
                }
                
                // Walk through all text nodes and replace placeholders
                function walkNode(node) {
                    if (node.nodeType === 3) { // Text node
                        let text = node.textContent;
                        const parent = node.parentElement;
                        let changed = false;
                        
                        // Replace route name (with or without spaces)
                        const namePattern = /\{\{\s*values\.travel\.name\s*\}\}/g;
                        if (namePattern.test(text)) {
                            text = text.replace(namePattern, (match) => {
                                changed = true;
                                // Check if this is in a reverse direction tab
                                if (parent) {
                                    const tabText = parent.textContent || '';
                                    if (tabText.includes('(Reverse)')) {
                                        const routeParts = data.travel.name.split(' - ');
                                        if (routeParts.length === 2) {
                                            return `${routeParts[1]} - ${routeParts[0]}`;
                                        }
                                    }
                                }
                                return data.travel.name;
                            });
                        }
                        
                        // Replace stop names (handle both with and without spaces in template)
                        const stopPattern = /\{\{\s*values\.travel\.stops\.(\d+)\.stop\s*\}\}/g;
                        if (stopPattern.test(text)) {
                            text = text.replace(stopPattern, (match, index) => {
                                changed = true;
                                const stop = data.travel.stops[parseInt(index)];
                                if (!stop) return match;
                                // Check if parent has stop-name class
                                if (parent && parent.classList.contains('stop-name')) {
                                    return getStopName(stop.stop);
                                }
                                return stop.stop;
                            });
                        }
                        
                        // Replace arrival times
                        const timePattern = /\{\{\s*values\.travel\.stops\.(\d+)\.arrival_time\s*\}\}/g;
                        if (timePattern.test(text)) {
                            text = text.replace(timePattern, (match, index) => {
                                changed = true;
                                const stop = data.travel.stops[parseInt(index)];
                                if (!stop) return match;
                                // Check if parent has arrival-clock class
                                if (parent && parent.classList.contains('arrival-clock')) {
                                    // Use arrival_time from currentData (which has been calculated)
                                    const calculatedStop = currentData.travel.stops[parseInt(index)];
                                    return formatTime(calculatedStop ? calculatedStop.arrival_time : '00:00:00 AM');
                                }
                                const calculatedStop = currentData.travel.stops[parseInt(index)];
                                return calculatedStop ? calculatedStop.arrival_time : '00:00:00 AM';
                            });
                        }
                        
                        if (changed) {
                            node.textContent = text;
                        }
                    } else {
                        // Recursively process child nodes
                        for (let i = 0; i < node.childNodes.length; i++) {
                            walkNode(node.childNodes[i]);
                        }
                    }
                }
                
            // Start walking from body
            const beforeCount = (document.body.textContent.match(/\{\{/g) || []).length;
            walkNode(document.body);
            const afterCount = (document.body.textContent.match(/\{\{/g) || []).length;
            
            
            // Calculate animation timing based on arrival times
            function parseTime(timeStr) {
                // Parse "10:00:00 PM" or "10:00:15 PM" format
                const [timePart, period] = timeStr.trim().split(/\s+/);
                const parts = timePart.split(':');
                const hours = parseInt(parts[0]) || 0;
                const minutes = parseInt(parts[1]) || 0;
                const seconds = parseInt(parts[2]) || 0;
                
                // Convert to seconds since midnight
                let totalSeconds = hours * 3600 + minutes * 60 + seconds;
                
                // Handle AM/PM
                if (period) {
                    const periodUpper = period.toUpperCase();
                    if (periodUpper === 'PM' && hours !== 12) {
                        totalSeconds += 12 * 3600;
                    } else if (periodUpper === 'AM' && hours === 12) {
                        totalSeconds -= 12 * 3600;
                    }
                }
                
                return totalSeconds;
            }
            
            // Calculate time difference in seconds between two time strings
            function getTimeDifference(timeStr1, timeStr2) {
                const time1 = parseTime(timeStr1);
                const time2 = parseTime(timeStr2);
                return time2 - time1;
            }
            
            // Make getTimeDifference globally accessible
            window.getTimeDifference = getTimeDifference;
            
            function calculateAnimationTiming() {
                // Use currentData which may have updated arrival times
                const calcData = currentData;
                if (!calcData.travel.stops || calcData.travel.stops.length < 2) return;
                
                const stops = calcData.travel.stops;
                const startTimeStr = stops[0].arrival_time;
                const endTimeStr = stops[stops.length - 1].arrival_time;
                const totalDuration = getTimeDifference(startTimeStr, endTimeStr); // in seconds
                
                
                // Verify first interval
                if (stops.length > 1) {
                    const firstInterval = getTimeDifference(stops[0].arrival_time, stops[1].arrival_time);
                }
                
                // Update CSS variable for animation duration
                document.documentElement.style.setProperty('--animation-duration', `${totalDuration}s`);
                // Verify the value was set
                const computedDuration = getComputedStyle(document.documentElement).getPropertyValue('--animation-duration');
                
                // Calculate keyframe percentages for each stop
                // Ensure bus reaches each stop at the exact time the marker activates
                // Use fixed pixel values instead of calc() for better animation interpolation
                const keyframes = [];
                const baseTopPx = 16 + 16 + 30; // 62px - first stop position
                const stopSpacingPx = 112; // spacing between stops
                
                // Start at first stop (0%)
                keyframes.push(`0% { top: ${baseTopPx}px; }`);
                
                // Add keyframe for each stop at the exact time it should arrive
                for (let i = 1; i < stops.length; i++) {
                    const elapsed = getTimeDifference(stops[0].arrival_time, stops[i].arrival_time);
                    const percentage = totalDuration > 0 ? (elapsed / totalDuration) * 100 : 0;
                    const stopIndex = i;
                    // Calculate exact pixel position: base + (stop index * spacing)
                    const stopTopPx = baseTopPx + (stopIndex * stopSpacingPx);
                    
                    // Add keyframe at exact percentage - bus should be at this position at this time
                    keyframes.push(`${percentage.toFixed(6)}% { top: ${stopTopPx}px; }`);
                    
                    // Verify: at this percentage, the bus should reach this stop
                    const expectedTimeAtPercentage = (percentage / 100) * totalDuration;
                }
                
                // Ensure last stop is at 100% (might already be there, but ensure it)
                const lastStopIndex = stops.length - 1;
                const lastStopTopPx = baseTopPx + (lastStopIndex * stopSpacingPx);
                const lastPercentage = keyframes[keyframes.length - 1].match(/^([\d.]+)%/)?.[1];
                if (!lastPercentage || parseFloat(lastPercentage) < 100) {
                    keyframes.push(`100% { top: ${lastStopTopPx}px; }`);
                }
                
                // Use keyframes as-is - linear timing will handle smooth interpolation
                const finalKeyframes = keyframes;
                
                // Create or update the keyframe animation
                const styleId = 'dynamic-bus-animation';
                let styleElement = document.getElementById(styleId);
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    // Append at the end of head to ensure it overrides any existing styles
                    document.head.appendChild(styleElement);
                } else {
                    // If it exists, remove and recreate to ensure fresh injection
                    styleElement.remove();
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                
                // Generate stop marker animations using actual time delays
                const stopAnimations = [];
                for (let i = 0; i < stops.length; i++) {
                    const elapsed = getTimeDifference(stops[0].arrival_time, stops[i].arrival_time); // in seconds
                    const nextElapsed = i < stops.length - 1 ? getTimeDifference(stops[0].arrival_time, stops[i + 1].arrival_time) : totalDuration;
                    
                    stopAnimations.push(`
                        #animationToggle:checked ~ .app-container .stop-item:nth-child(${i + 1}) .stop-circle {
                            animation: stopPassed 0s ${nextElapsed}s forwards !important;
                        }
                    `);
                }
                
                // Sort keyframes by percentage to ensure proper order
                const sortedKeyframes = finalKeyframes.sort((a, b) => {
                    const percentA = parseFloat(a.match(/^([\d.]+)%/)?.[1] || '0');
                    const percentB = parseFloat(b.match(/^([\d.]+)%/)?.[1] || '0');
                    return percentA - percentB;
                });
                
                // Remove duplicates - keep only the last keyframe for each unique percentage
                const uniqueKeyframes = [];
                const keyframeMap = new Map();
                
                // First pass: collect all keyframes, keeping the last one for each percentage
                for (const keyframe of sortedKeyframes) {
                    const match = keyframe.match(/^([\d.]+)%/);
                    if (match) {
                        const percent = parseFloat(match[1]);
                        keyframeMap.set(percent, keyframe);
                    }
                }
                
                // Second pass: create sorted array from map
                const sortedPercents = Array.from(keyframeMap.keys()).sort((a, b) => a - b);
                for (const percent of sortedPercents) {
                    uniqueKeyframes.push(keyframeMap.get(percent));
                }
                
                // Create keyframes for route line red overlay (height animation)
                // The red overlay should match the bus position exactly
                // Route line starts at: calc(16px + 16px + 40px) = 72px
                // Bus starts at: 62px (10px above route line start)
                // Bus travels from 62px to last stop position
                const routeLineKeyframes = [];
                const routeLineStartPx = 16 + 16 + 40; // 72px - route line top
                const busStartPx = baseTopPx; // 62px - bus start position
                const busEndPx = baseTopPx + ((stops.length - 1) * stopSpacingPx); // Last stop position
                const routeLineTotalHeight = busEndPx - routeLineStartPx; // Total distance the red should cover
                
                // At 0%, bus is at 62px, which is 10px above route line (72px), so red height = 0
                routeLineKeyframes.push(`0% { height: 0px; }`);
                
                // Add keyframes at the same percentages as bus movement
                for (let i = 1; i < stops.length; i++) {
                    const elapsed = getTimeDifference(stops[0].arrival_time, stops[i].arrival_time);
                    const percentage = totalDuration > 0 ? (elapsed / totalDuration) * 100 : 0;
                    // Calculate bus position at this percentage
                    const busPositionPx = baseTopPx + (i * stopSpacingPx);
                    // Calculate red overlay height: bus position minus route line start
                    // But only if bus is below route line start
                    const redHeightPx = Math.max(0, busPositionPx - routeLineStartPx);
                    routeLineKeyframes.push(`${percentage.toFixed(6)}% { height: ${redHeightPx}px; }`);
                }
                // At 100%, bus is at last stop, red should cover to bus position
                const finalRedHeightPx = Math.max(0, busEndPx - routeLineStartPx);
                routeLineKeyframes.push(`100% { height: ${finalRedHeightPx}px; }`);
                
                // Create the animation CSS with explicit duration
                const animationCSS = `
                    @keyframes busMoveMobile {
                        ${uniqueKeyframes.join('\n                        ')}
                    }
                    @keyframes routeLineCovered {
                        ${routeLineKeyframes.join('\n                        ')}
                    }
                    ${stopAnimations.join('\n                    ')}
                    
                    /* Force animation duration - must match stop marker timing - maximum specificity */
                    html body #animationToggle:checked ~ .app-container .route-visualization .bus-icon-mobile,
                    html body #animationToggle:checked ~ .app-container .bus-icon-mobile {
                        /* Remove any transitions that might interfere */
                        transition: none !important;
                        /* Set animation properties explicitly */
                        animation: busMoveMobile ${totalDuration}s linear 0s 1 forwards running !important;
                        /* Individual properties for maximum compatibility */
                        animation-name: busMoveMobile !important;
                        animation-duration: ${totalDuration}s !important;
                        animation-timing-function: linear !important;
                        animation-fill-mode: forwards !important;
                        animation-delay: 0s !important;
                        animation-iteration-count: 1 !important;
                        animation-play-state: running !important;
                        /* Performance optimization */
                        will-change: top !important;
                        /* Ensure no transform interference */
                        transform: translateY(0) !important;
                    }
                    
                    /* Pause animation when pauseToggle is checked (both toggles are siblings before .app-container) */
                    html body #animationToggle:checked ~ #pauseToggle:checked ~ .app-container .route-visualization .bus-icon-mobile,
                    html body #animationToggle:checked ~ #pauseToggle:checked ~ .app-container .bus-icon-mobile {
                        animation-play-state: paused !important;
                    }
                    
                    /* Animate route line red overlay to show covered distance */
                    html body #animationToggle:checked ~ .app-container .route-line::before {
                        animation: routeLineCovered ${totalDuration}s linear 0s 1 forwards running !important;
                        animation-name: routeLineCovered !important;
                        animation-duration: ${totalDuration}s !important;
                        animation-timing-function: linear !important;
                        animation-fill-mode: forwards !important;
                    }
                    
                    /* Pause route line animation when pauseToggle is checked */
                    html body #animationToggle:checked ~ #pauseToggle:checked ~ .app-container .route-line::before {
                        animation-play-state: paused !important;
                    }
                    
                    /* Reset route line when animation is stopped */
                    html body #animationToggle:not(:checked) ~ .app-container .route-line::before {
                        animation-play-state: paused !important;
                    }
                    
                    /* When unchecked, pause animation but keep position */
                    html body #animationToggle:not(:checked) ~ .app-container .bus-icon-mobile {
                        animation-play-state: paused !important;
                        /* Don't reset position - forwards fill-mode keeps it */
                    }
                `;
                
                styleElement.textContent = animationCSS;
                
                // Listen for animation toggle to verify and debug animation
                const animationToggle = document.getElementById('animationToggle');
                if (animationToggle) {
                    // Remove any existing listeners to avoid duplicates
                    const newToggle = animationToggle.cloneNode(true);
                    animationToggle.parentNode.replaceChild(newToggle, animationToggle);
                    
                    newToggle.addEventListener('change', function() {
                        setTimeout(() => {
                            const busIcon = document.querySelector('.bus-icon-mobile');
                            if (busIcon) {
                                if (this.checked) {
                                    // Reset tracking variables when starting
                                    currentStopIndex = 0;
                                    reachedStops = [];
                                    pausedTimeOffset = 0;
                                    originalArrivalTimes = [];
                                    
                                    // Freeze the start time when start button is clicked
                                    if (!startTime) {
                                        startTime = currentTime || getCurrentTimeString();
                                        // Stop time update interval
                                        if (timeUpdateInterval) {
                                            clearInterval(timeUpdateInterval);
                                            timeUpdateInterval = null;
                                        }
                                    }
                                    
                                    // Uncheck pause toggle when starting
                                    const pauseToggle = document.getElementById('pauseToggle');
                                    if (pauseToggle) {
                                        pauseToggle.checked = false;
                                    }
                                    stopPauseTimeUpdate();
                                    // Remove pause style override
                                    const pauseStyle = document.getElementById('pause-style-override');
                                    if (pauseStyle) {
                                        pauseStyle.remove();
                                    }
                                    
                                    // Recalculate arrival times with frozen start time
                                    calculateArrivalTimes();
                                    // Initialize original arrival times
                                    if (currentData.travel && currentData.travel.stops) {
                                        currentData.travel.stops.forEach((stop, index) => {
                                            if (!originalArrivalTimes[index]) {
                                                originalArrivalTimes[index] = stop.arrival_time;
                                            }
                                        });
                                    }
                                    updateTimeDisplay();
                                    // Recalculate animation timing
                                    calculateAnimationTiming();
                                    
                                    // Start tracking bus position
                                    startBusPositionTracking();
                                    
                                    // Reset to beginning when starting
                                    busIcon.style.animation = 'none';
                                    busIcon.style.top = '62px';
                                    busIcon.offsetHeight; // Force reflow
                                    busIcon.style.removeProperty('animation');
                                    busIcon.style.removeProperty('top');
                                    // Debug animation state
                                    const computedStyle = window.getComputedStyle(busIcon);
                                    const animName = computedStyle.animationName;
                                    const animDuration = computedStyle.animationDuration;
                                    const animTiming = computedStyle.animationTimingFunction;
                                    const animState = computedStyle.animationPlayState;
                                    
                                    // Check if keyframes exist
                                    const keyframesRule = Array.from(document.styleSheets)
                                        .flatMap(sheet => {
                                            try {
                                                return Array.from(sheet.cssRules || []);
                                            } catch (e) {
                                                return [];
                                            }
                                        })
                                        .find(rule => rule.name === 'busMoveMobile');
                                    
                                    // Verify animation is correct
                                    
                                    // Monitor bus position at key times
                                    const expectedPositions = [];
                                    for (let i = 0; i < stops.length; i++) {
                                        const elapsed = getTimeDifference(stops[0].arrival_time, stops[i].arrival_time);
                                        const expectedTop = 62 + (i * 112); // Match stopSpacingPx = 112
                                        expectedPositions.push({ time: elapsed, top: expectedTop, stop: i + 1 });
                                    }
                                    
                                    // Check position at intervals
                                    let checkCount = 0;
                                    const positionChecker = setInterval(() => {
                                        if (!newToggle.checked) {
                                            clearInterval(positionChecker);
                                            return;
                                        }
                                        
                                        checkCount++;
                                        const currentTop = parseFloat(window.getComputedStyle(busIcon).top);
                                        const animElapsed = (checkCount * 0.5); // Check every 0.5s
                                        
                                        // Find expected position for this time
                                        const expected = expectedPositions.find(p => Math.abs(p.time - animElapsed) < 1);
                                        if (expected) {
                                            const diff = Math.abs(currentTop - expected.top);
                                        }
                                        
                                        if (animElapsed > totalDuration) {
                                            clearInterval(positionChecker);
                                        }
                                    }, 500); // Check every 500ms
                                }
                            }
                        }, 50);
                    });
                }
                
            }
            
            calculateAnimationTiming();
        }
        
        // Add pause toggle event listener
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded: Setting up pause button listener');
            const pauseToggle = document.getElementById('pauseToggle');
            const pauseResumeBtn = document.getElementById('pauseResumeBtn');
            const animationToggle = document.getElementById('animationToggle');
            
            console.log('Pause toggle element:', pauseToggle);
            console.log('Pause button element:', pauseResumeBtn);
            console.log('Animation toggle element:', animationToggle);
            
            if (pauseToggle && pauseResumeBtn) {
                console.log('Adding change event listener to pauseToggle');
                pauseToggle.addEventListener('change', function() {
                    console.log('Pause toggle changed! Checked:', this.checked);
                    console.log('Animation toggle checked:', animationToggle ? animationToggle.checked : 'null');
                    
                    // Check if animation exists by checking the bus icon
                    const busIcon = document.querySelector('.bus-icon-mobile');
                    let animationExists = false;
                    if (busIcon) {
                        const computedStyle = window.getComputedStyle(busIcon);
                        const animName = computedStyle.animationName;
                        const animPlayState = computedStyle.animationPlayState;
                        // Animation exists if it has a name (even if paused)
                        animationExists = (animName && animName !== 'none');
                        // console.log('Animation state check - animName:', animName, 'animPlayState:', animPlayState, 'animationExists:', animationExists);
                    }
                    
                    // Allow pause/resume if animation exists (regardless of current play state)
                    // Also check if animation toggle is checked OR if animation actually exists
                    const canPause = animationExists || (animationToggle && animationToggle.checked);
                    if (!canPause) {
                        console.log('Animation does not exist, preventing pause');
                        this.checked = false;
                        return;
                    }
                    
                    // console.log('Can pause/resume:', canPause);
                    
                    if (this.checked) {
                        console.log('PAUSING animation');
                        // Pause: start updating current stop time
                        getCurrentBusStopIndex(); // Update current stop index
                        console.log('Current stop index:', currentStopIndex);
                        startPauseTimeUpdate();
                        console.log('Started pause time update interval');
                        
                        // Directly pause the animation via JavaScript
                        // We'll add a style element with higher specificity
                        let pauseStyle = document.getElementById('pause-style-override');
                        if (!pauseStyle) {
                            console.log('Creating pause style override element');
                            pauseStyle = document.createElement('style');
                            pauseStyle.id = 'pause-style-override';
                            document.head.appendChild(pauseStyle);
                        }
                        pauseStyle.textContent = `
                            html body .app-container .bus-icon-mobile {
                                animation-play-state: paused !important;
                            }
                            html body .app-container .route-line::before {
                                animation-play-state: paused !important;
                            }
                        `;
                        console.log('Pause style override applied');
                        
                        // Check animation state
                        const busIcon = document.querySelector('.bus-icon-mobile');
                        if (busIcon) {
                            const computedStyle = window.getComputedStyle(busIcon);
                            console.log('Bus icon animation play state:', computedStyle.animationPlayState);
                            console.log('Bus icon animation name:', computedStyle.animationName);
                        }
                        
                        // Update button text
                        const textSpan = pauseResumeBtn.querySelector('.pause-resume-text');
                        if (textSpan) {
                            textSpan.textContent = 'Resume';
                            console.log('Button text changed to: Resume');
                        }
                    } else {
                        console.log('RESUMING animation');
                        // Resume: stop updating time
                        stopPauseTimeUpdate();
                        console.log('Stopped pause time update interval');
                        
                        // Remove the pause style override
                        const pauseStyle = document.getElementById('pause-style-override');
                        if (pauseStyle) {
                            pauseStyle.remove();
                            console.log('Removed pause style override');
                        }
                        
                        // Check animation state
                        const busIcon = document.querySelector('.bus-icon-mobile');
                        if (busIcon) {
                            const computedStyle = window.getComputedStyle(busIcon);
                            console.log('Bus icon animation play state:', computedStyle.animationPlayState);
                        }
                        
                        // Update button text
                        const textSpan = pauseResumeBtn.querySelector('.pause-resume-text');
                        if (textSpan) {
                            textSpan.textContent = 'Pause';
                            console.log('Button text changed to: Pause');
                        }
                    }
                });
            } else {
                console.error('Pause toggle or button not found!', { pauseToggle, pauseResumeBtn });
            }
            
            // Disable pause button when animation stops
            if (animationToggle) {
                animationToggle.addEventListener('change', function() {
                    console.log('Animation toggle changed! Checked:', this.checked);
                    if (!this.checked) {
                        console.log('Animation stopped, resetting pause');
                        // Uncheck pause when animation stops
                        if (pauseToggle) {
                            pauseToggle.checked = false;
                            console.log('Pause toggle unchecked');
                        }
                        stopPauseTimeUpdate();
                        // Remove pause style override
                        const pauseStyle = document.getElementById('pause-style-override');
                        if (pauseStyle) {
                            pauseStyle.remove();
                            console.log('Removed pause style override');
                        }
                        if (pauseResumeBtn) {
                            const textSpan = pauseResumeBtn.querySelector('.pause-resume-text');
                            if (textSpan) {
                                textSpan.textContent = 'Pause';
                                console.log('Button text reset to: Pause');
                            }
                        }
                    } else {
                        console.log('Animation started');
                    }
                });
            }
        });
        
        // Load values when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadValues);
        } else {
            loadValues();
        }
    </script>
</body>
</html>

